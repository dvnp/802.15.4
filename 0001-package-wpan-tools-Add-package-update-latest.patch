From f4fc03124e1cc5ffefa6208a20c9325ab3b6e5a9 Mon Sep 17 00:00:00 2001
From: Diogenes Pereira <dvnp@cesar.org.br>
Date: Wed, 6 Sep 2017 15:12:06 -0300
Subject: [PATCH] package/wpan-tools: Add package update latest

Cherry pick from commit 77ae6f363e0bbd667f688fbfcb1a33024c026c2d and
patches to upgrade security, examples and configuration scripts.

Signed-off-by: Diogenes Pereira <dvnp@cesar.org.br>
---
 ...01-security-add-nl802154-security-support.patch | 1273 ++++++++++++++++++++
 ...tras.h-fix-compatibility-with-libnl-3.3.0.patch |   49 -
 ...02-security-add-store-and-restore-scripts.patch |  118 ++
 .../wpan-tools/0003-examples-improvements.patch    |  413 +++++++
 package/wpan-tools/wpan-tools.hash                 |    4 -
 package/wpan-tools/wpan-tools.mk                   |   11 +-
 6 files changed, 1811 insertions(+), 57 deletions(-)
 create mode 100644 package/wpan-tools/0001-security-add-nl802154-security-support.patch
 delete mode 100644 package/wpan-tools/0001-src-nl_extras.h-fix-compatibility-with-libnl-3.3.0.patch
 create mode 100644 package/wpan-tools/0002-security-add-store-and-restore-scripts.patch
 create mode 100644 package/wpan-tools/0003-examples-improvements.patch
 delete mode 100644 package/wpan-tools/wpan-tools.hash

diff --git a/package/wpan-tools/0001-security-add-nl802154-security-support.patch b/package/wpan-tools/0001-security-add-nl802154-security-support.patch
new file mode 100644
index 0000000..5e3cc77
--- /dev/null
+++ b/package/wpan-tools/0001-security-add-nl802154-security-support.patch
@@ -0,0 +1,1273 @@
+This patch introduce support for the experimental seucirty support for
+nl802154. We currently support add/del settings for manipulating
+security table entries. The dump functionality is a "really" keep it
+short and stupid handling, the dump will printout the printout the right
+add calls which was called to add the entry. This can be used for
+storing the current security tables by some script. The interface
+argument is replaced by $WPAN_DEV variable, so it's possible to move one
+interface configuration to another one.
+
+Signed-off-by: Alexander Aring <alex.aring@xxxxxxxxx>
+---
+ src/Makefile.am |    1 +
+ src/interface.c |  100 +++++
+ src/security.c  | 1118 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 1219 insertions(+)
+ create mode 100644 src/security.c
+
+diff --git a/src/Makefile.am b/src/Makefile.am
+index 2d54576..b2177a2 100644
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -9,6 +9,7 @@ iwpan_SOURCES = \
+ 	interface.c \
+ 	phy.c \
+ 	mac.c \
++	security.c \
+ 	nl_extras.h \
+ 	nl802154.h
+ 
+diff --git a/src/interface.c b/src/interface.c
+index 85d40a8..076e7c3 100644
+--- a/src/interface.c
++++ b/src/interface.c
+@@ -10,6 +10,7 @@
+ #include <netlink/msg.h>
+ #include <netlink/attr.h>
+ 
++#define CONFIG_IEEE802154_NL802154_EXPERIMENTAL
+ #include "nl802154.h"
+ #include "nl_extras.h"
+ #include "iwpan.h"
+@@ -226,6 +227,105 @@ static int print_iface_handler(struct nl_msg *msg, void *arg)
+ 	if (tb_msg[NL802154_ATTR_ACKREQ_DEFAULT])
+ 		printf("%s\tackreq_default %d\n", indent, nla_get_u8(tb_msg[NL802154_ATTR_ACKREQ_DEFAULT]));
+ 
++	if (tb_msg[NL802154_ATTR_SEC_ENABLED])
++		printf("%s\tsecurity %d\n", indent, nla_get_u8(tb_msg[NL802154_ATTR_SEC_ENABLED]));
++	if (tb_msg[NL802154_ATTR_SEC_OUT_LEVEL])
++		printf("%s\tout_level %d\n", indent, nla_get_u8(tb_msg[NL802154_ATTR_SEC_OUT_LEVEL]));
++	if (tb_msg[NL802154_ATTR_SEC_OUT_KEY_ID]) {
++		struct nlattr *tb_key_id[NL802154_KEY_ID_ATTR_MAX + 1];
++		static struct nla_policy key_id_policy[NL802154_KEY_ID_ATTR_MAX + 1] = {
++		        [NL802154_KEY_ID_ATTR_MODE] = { .type = NLA_U32 },
++		        [NL802154_KEY_ID_ATTR_INDEX] = { .type = NLA_U8 },
++		        [NL802154_KEY_ID_ATTR_IMPLICIT] = { .type = NLA_NESTED },
++		        [NL802154_KEY_ID_ATTR_SOURCE_SHORT] = { .type = NLA_U32 },
++		        [NL802154_KEY_ID_ATTR_SOURCE_EXTENDED] = { .type = NLA_U64 },
++		};
++
++		nla_parse_nested(tb_key_id, NL802154_KEY_ID_ATTR_MAX,
++				 tb_msg[NL802154_ATTR_SEC_OUT_KEY_ID], key_id_policy);
++		printf("%s\tout_key_id\n", indent);
++
++		if (tb_key_id[NL802154_KEY_ID_ATTR_MODE]) {
++			enum nl802154_key_id_modes key_id_mode;
++
++			key_id_mode = nla_get_u32(tb_key_id[NL802154_KEY_ID_ATTR_MODE]);
++			switch (key_id_mode) {
++			case NL802154_KEY_ID_MODE_IMPLICIT:
++				printf("%s\t\tmode implicit\n", indent);
++				if (tb_key_id[NL802154_KEY_ID_ATTR_IMPLICIT]) {
++					struct nlattr *tb_dev_addr[NL802154_DEV_ADDR_ATTR_MAX + 1];
++					static struct nla_policy dev_addr_policy[NL802154_DEV_ADDR_ATTR_MAX + 1] = {
++						[NL802154_DEV_ADDR_ATTR_PAN_ID] = { .type = NLA_U16 },
++						[NL802154_DEV_ADDR_ATTR_MODE] = { .type = NLA_U32 },
++						[NL802154_DEV_ADDR_ATTR_SHORT] = { .type = NLA_U16 },
++						[NL802154_DEV_ADDR_ATTR_EXTENDED] = { .type = NLA_U64 },
++					};
++
++					nla_parse_nested(tb_dev_addr, NL802154_DEV_ADDR_ATTR_MAX,
++							 tb_key_id[NL802154_KEY_ID_ATTR_IMPLICIT],
++							 dev_addr_policy);
++
++					if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_PAN_ID])
++						printf("%s\t\tpan_id 0x%04x\n", indent,
++						       le16toh(nla_get_u16(tb_dev_addr[NL802154_DEV_ADDR_ATTR_PAN_ID])));
++
++					if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_MODE]) {
++						enum nl802154_dev_addr_modes dev_addr_mode;
++						dev_addr_mode = nla_get_u32(tb_dev_addr[NL802154_DEV_ADDR_ATTR_MODE]);
++						printf("%s\t\taddr_mode %d\n", indent, dev_addr_mode);
++						switch (dev_addr_mode) {
++						case NL802154_DEV_ADDR_SHORT:
++							if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_SHORT])
++								printf("%s\t\tshort_addr 0x%04x\n", indent,
++								       le16toh(nla_get_u16(tb_dev_addr[NL802154_DEV_ADDR_ATTR_SHORT])));
++							break;
++						case NL802154_DEV_ADDR_EXTENDED:
++							if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_EXTENDED])
++								printf("%s\t\textended_addr 0x%016" PRIx64 "\n", indent,
++								       le64toh(nla_get_u64(tb_dev_addr[NL802154_DEV_ADDR_ATTR_EXTENDED])));
++							break;
++						default:
++							printf("%s\t\tunkown address\n", indent);
++							break;
++						}
++					}
++				}
++				break;
++			case NL802154_KEY_ID_MODE_INDEX:
++				printf("%s\t\tmode index\n", indent);
++				if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++					printf("%s\t\tindex 0x%02x\n", indent,
++					       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++				break;
++			case NL802154_KEY_ID_MODE_INDEX_SHORT:
++				printf("%s\t\tmode index_short\n", indent);
++				if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++					printf("%s\t\tindex 0x%02x\n", indent,
++					       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++
++				if (tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_SHORT])
++					printf("%s\t\tsource_short 0x%08lx\n", indent,
++					       le32toh(nla_get_u32(tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_SHORT])));
++				break;
++			case NL802154_KEY_ID_MODE_INDEX_EXTENDED:
++				printf("%s\t\tmode index_extended\n", indent);
++				if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++					printf("%s\t\tindex 0x%02x\n", indent,
++					       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++
++				if (tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])
++					printf("%s\t\tsource_extended 0x%" PRIx64 "\n", indent,
++					       le64toh(nla_get_u64(tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])));
++				break;
++			default:
++				printf("%s\t\tkey_mode unknown\n", indent);
++			}
++		}
++	}
++
++	if (tb_msg[NL802154_ATTR_SEC_FRAME_COUNTER])
++		printf("%s\tframe_counter 0x%08lx\n", indent, be32toh(nla_get_u32(tb_msg[NL802154_ATTR_SEC_FRAME_COUNTER])));
++
+ 	return NL_SKIP;
+ }
+ 
+diff --git a/src/security.c b/src/security.c
+new file mode 100644
+index 0000000..3928dee
+--- /dev/null
++++ b/src/security.c
+@@ -0,0 +1,1118 @@
++#include <net/if.h>
++#include <errno.h>
++#include <string.h>
++#include <stdbool.h>
++#include <inttypes.h>
++
++#include <netlink/genl/genl.h>
++#include <netlink/genl/family.h>
++#include <netlink/genl/ctrl.h>
++#include <netlink/msg.h>
++#include <netlink/attr.h>
++
++#include "nl_extras.h"
++#define CONFIG_IEEE802154_NL802154_EXPERIMENTAL
++#include "nl802154.h"
++#include "iwpan.h"
++
++static int handle_security_set(struct nl802154_state *state, struct nl_cb *cb,
++			       struct nl_msg *msg, int argc, char **argv,
++			       enum id_input id)
++{
++	unsigned long enabled;
++	char *end;
++
++	if (argc < 1)
++		return 1;
++
++	/* enabled */
++	enabled = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (enabled > UINT8_MAX)
++		return 1;
++
++	NLA_PUT_U8(msg, NL802154_ATTR_SEC_ENABLED, enabled);
++
++	return 0;
++
++nla_put_failure:
++	return -ENOBUFS;
++}
++COMMAND(set, security, "<1|0>", NL802154_CMD_SET_SEC_PARAMS, 0, CIB_NETDEV,
++	handle_security_set, NULL);
++
++static int handle_parse_key_id(struct nl_msg *msg, int attrtype,
++			       int *argc, char ***argv)
++{
++	struct nl_msg *key_id_msg, *dev_addr_msg = NULL;
++	unsigned long key_mode, dev_addr_mode, short_addr, pan_id, index;
++	unsigned long long extended_addr;
++	char *end;
++
++	if ((*argc) < 1)
++		return 1;
++
++	/* key_mode */
++	key_mode = strtoul((*argv)[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	(*argc)--;
++	(*argv)++;
++
++	switch (key_mode) {
++	case NL802154_KEY_ID_MODE_IMPLICIT:
++		if ((*argc) < 2)
++			return 1;
++
++		/* pan_id */
++		pan_id = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		if (pan_id > UINT16_MAX)
++			return 1;
++
++		(*argc)--;
++		(*argv)++;
++
++		/* dev_addr_mode */
++		dev_addr_mode = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		(*argc)--;
++		(*argv)++;
++
++		switch (dev_addr_mode) {
++		case NL802154_DEV_ADDR_SHORT:
++			if ((*argc) < 1)
++				return 1;
++
++			/* dev_addr_short */
++			short_addr = strtoul((*argv)[0], &end, 0);
++			if (*end != '\0')
++				return 1;
++
++			if (short_addr > UINT16_MAX)
++				return 1;
++			break;
++		case NL802154_DEV_ADDR_EXTENDED:
++			if ((*argc) < 1)
++				return 1;
++
++			/* dev_addr_short */
++			extended_addr = strtoull((*argv)[0], &end, 0);
++			if (*end != '\0')
++				return 1;
++			break;
++		default:
++			return 1;
++		}
++
++		key_id_msg = nlmsg_alloc();
++		if (!key_id_msg)
++			return -ENOMEM;
++
++		dev_addr_msg = nlmsg_alloc();
++		if (!dev_addr_msg)
++			return -ENOMEM;
++
++		NLA_PUT_U16(dev_addr_msg, NL802154_DEV_ADDR_ATTR_PAN_ID, pan_id);
++		NLA_PUT_U32(dev_addr_msg, NL802154_DEV_ADDR_ATTR_MODE, dev_addr_mode);
++		NLA_PUT_U16(dev_addr_msg, NL802154_DEV_ADDR_ATTR_SHORT, htole16(short_addr));
++		NLA_PUT_U64(dev_addr_msg, NL802154_DEV_ADDR_ATTR_EXTENDED, htole64(extended_addr));
++
++		nla_put_nested(key_id_msg, NL802154_KEY_ID_ATTR_IMPLICIT, dev_addr_msg);
++
++		nlmsg_free(dev_addr_msg);
++		dev_addr_msg = NULL;
++
++		break;
++	case NL802154_KEY_ID_MODE_INDEX:
++		if ((*argc) < 1)
++			return 1;
++
++		/* index */
++		index = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		if (index > UINT8_MAX)
++			return 1;
++
++		key_id_msg = nlmsg_alloc();
++		if (!key_id_msg)
++			return -ENOMEM;
++
++		NLA_PUT_U8(key_id_msg, NL802154_KEY_ID_ATTR_INDEX, index);
++		break;
++	case NL802154_KEY_ID_MODE_INDEX_SHORT:
++		if ((*argc) < 2)
++			return 1;
++
++		/* index */
++		index = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		if (index > UINT8_MAX)
++			return 1;
++
++		(*argc)--;
++		(*argv)++;
++
++		/* source_short */
++		short_addr = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		key_id_msg = nlmsg_alloc();
++		if (!key_id_msg)
++			return -ENOMEM;
++
++		NLA_PUT_U8(key_id_msg, NL802154_KEY_ID_ATTR_INDEX, index);
++		NLA_PUT_U32(key_id_msg, NL802154_KEY_ID_ATTR_SOURCE_SHORT,
++			    htole32(short_addr));
++		break;
++	case NL802154_KEY_ID_MODE_INDEX_EXTENDED:
++		if ((*argc) < 2)
++			return 1;
++
++		/* index */
++		index = strtoul((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		if (index > UINT8_MAX)
++			return 1;
++
++		(*argc)--;
++		(*argv)++;
++
++		/* source_extended */
++		extended_addr = strtoull((*argv)[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++
++		key_id_msg = nlmsg_alloc();
++		if (!key_id_msg)
++			return -ENOMEM;
++
++		NLA_PUT_U8(key_id_msg, NL802154_KEY_ID_ATTR_INDEX, index);
++		NLA_PUT_U64(key_id_msg, NL802154_KEY_ID_ATTR_SOURCE_EXTENDED,
++			    htole64(extended_addr));
++		break;
++	default:
++		return 1;
++	}
++
++	NLA_PUT_U32(key_id_msg, NL802154_KEY_ID_ATTR_MODE, key_mode);
++	nla_put_nested(msg, attrtype, key_id_msg);
++
++	nlmsg_free(key_id_msg);
++
++	return 0;
++
++nla_put_failure:
++	if (!dev_addr_msg)
++		nlmsg_free(dev_addr_msg);
++
++	nlmsg_free(key_id_msg);
++	return -ENOBUFS;
++}
++
++static int handle_out_key_id_set(struct nl802154_state *state, struct nl_cb *cb,
++				 struct nl_msg *msg, int argc, char **argv,
++				 enum id_input id)
++{
++	return handle_parse_key_id(msg, NL802154_ATTR_SEC_OUT_KEY_ID, &argc, &argv);
++
++}
++COMMAND(set, out_key_id,
++	"<0 <pan_id> <2 <short_addr>|3 <extended_addr>>>|"
++	"<1 <index>>|"
++	"<2 <index> <source_short>>|"
++	"<3 <index> <source_extended>>",
++	NL802154_CMD_SET_SEC_PARAMS, 0, CIB_NETDEV,
++	handle_out_key_id_set, NULL);
++
++static int handle_out_seclevel_set(struct nl802154_state *state, struct nl_cb *cb,
++				   struct nl_msg *msg, int argc, char **argv,
++				   enum id_input id)
++{
++	unsigned long seclevel;
++	char *end;
++
++	if (argc < 1)
++		return 1;
++
++	/* seclevel */
++	seclevel = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	NLA_PUT_U32(msg, NL802154_ATTR_SEC_OUT_LEVEL, seclevel);
++
++	return 0;
++
++nla_put_failure:
++	return -ENOBUFS;
++}
++COMMAND(set, out_level, "<out_level>", NL802154_CMD_SET_SEC_PARAMS, 0, CIB_NETDEV,
++	handle_out_seclevel_set, NULL);
++
++static int handle_frame_counter_set(struct nl802154_state *state, struct nl_cb *cb,
++				   struct nl_msg *msg, int argc, char **argv,
++				   enum id_input id)
++{
++	unsigned long frame_counter;
++	char *end;
++
++	/* frame_counter */
++	frame_counter = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	NLA_PUT_U32(msg, NL802154_ATTR_SEC_FRAME_COUNTER, htobe32(frame_counter));
++
++	return 0;
++
++nla_put_failure:
++	return -ENOBUFS;
++}
++COMMAND(set, frame_counter, "<frame_counter>", NL802154_CMD_SET_SEC_PARAMS, 0, CIB_NETDEV,
++	handle_frame_counter_set, NULL);
++
++SECTION(seclevel);
++
++static int print_seclevel_handler(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *tb[NL802154_ATTR_MAX + 1];
++	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
++
++	nla_parse(tb, NL802154_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
++		  genlmsg_attrlen(gnlh, 0), NULL);
++
++	if (tb[NL802154_ATTR_SEC_LEVEL]) {
++		struct nlattr *tb_seclevel[NL802154_SECLEVEL_ATTR_MAX + 1];
++		static struct nla_policy seclevel_policy[NL802154_SECLEVEL_ATTR_MAX + 1] = {
++			[NL802154_SECLEVEL_ATTR_LEVELS] = { .type = NLA_U32 },
++			[NL802154_SECLEVEL_ATTR_FRAME] = { .type = NLA_U32 },
++			[NL802154_SECLEVEL_ATTR_CMD_FRAME] = { .type = NLA_U32 },
++			[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE] = { .type = NLA_U8 },
++		};
++
++		if (nla_parse_nested(tb_seclevel, NL802154_SECLEVEL_ATTR_MAX,
++				     tb[NL802154_ATTR_SEC_LEVEL],
++				     seclevel_policy)) {
++			fprintf(stderr, "failed to parse nested attributes!\n");
++			return NL_SKIP;
++		}
++
++		printf("iwpan dev $WPAN_DEV seclevel add ");
++
++		if (tb_seclevel[NL802154_SECLEVEL_ATTR_LEVELS])
++			printf("0x%02lx ", nla_get_u8(tb_seclevel[NL802154_SECLEVEL_ATTR_LEVELS]));
++		if (tb_seclevel[NL802154_SECLEVEL_ATTR_FRAME])
++			printf("%d ", nla_get_u32(tb_seclevel[NL802154_SECLEVEL_ATTR_FRAME]));
++		if (tb_seclevel[NL802154_SECLEVEL_ATTR_CMD_FRAME])
++			printf("%d ", nla_get_u32(tb_seclevel[NL802154_SECLEVEL_ATTR_CMD_FRAME]));
++		if (tb_seclevel[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE])
++			printf("%d ", nla_get_u8(tb_seclevel[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE]));
++	}
++
++	printf("\n");
++
++	return NL_SKIP;
++}
++
++static int handle_seclevel_dump(struct nl802154_state *state,
++				struct nl_cb *cb,
++				struct nl_msg *msg,
++				int argc, char **argv,
++				enum id_input id)
++{
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_seclevel_handler, NULL);
++	return 0;
++}
++COMMAND(seclevel, dump, NULL,
++	NL802154_CMD_GET_SEC_LEVEL, NLM_F_DUMP, CIB_NETDEV, handle_seclevel_dump,
++	NULL);
++
++static int handle_seclevel_add(struct nl802154_state *state, struct nl_cb *cb,
++			       struct nl_msg *msg, int argc, char **argv,
++			       enum id_input id)
++{
++	struct nl_msg *seclevel_msg;
++	unsigned long levels, frame, cmd_id, dev_override;
++	char *end;
++
++	if (argc < 1)
++		return 1;
++
++	/* levels */
++	levels = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* frame */
++	frame = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (frame == NL802154_FRAME_CMD) {
++		argc--;
++		argv++;
++
++		if (argc < 1)
++			return 1;
++
++		/* cmd_frame */
++		cmd_id = strtoul(argv[0], &end, 0);
++		if (*end != '\0')
++			return 1;
++	}
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* dev_override */
++	dev_override = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (dev_override > UINT8_MAX)
++		return 1;
++
++	seclevel_msg = nlmsg_alloc();
++	if (!seclevel_msg)
++		return -ENOMEM;
++
++	NLA_PUT_U32(seclevel_msg, NL802154_SECLEVEL_ATTR_LEVELS, levels);
++	NLA_PUT_U32(seclevel_msg, NL802154_SECLEVEL_ATTR_FRAME, frame);
++	if (frame == NL802154_FRAME_CMD)
++		NLA_PUT_U32(seclevel_msg, NL802154_SECLEVEL_ATTR_CMD_FRAME, cmd_id);
++	NLA_PUT_U8(seclevel_msg, NL802154_SECLEVEL_ATTR_DEV_OVERRIDE, dev_override);
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_LEVEL, seclevel_msg);
++	nlmsg_free(seclevel_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(seclevel_msg);
++	return -ENOBUFS;
++}
++COMMAND(seclevel, add, "<levels> <frame_type|3 <cmd_id>> <dev_override>", NL802154_CMD_NEW_SEC_LEVEL, 0, CIB_NETDEV,
++	handle_seclevel_add, NULL);
++COMMAND(seclevel, del, "<levels> <frame_type|3 <cmd_id>> <dev_override>", NL802154_CMD_DEL_SEC_LEVEL, 0, CIB_NETDEV,
++	handle_seclevel_add, NULL);
++
++SECTION(device);
++
++static int print_device_handler(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *tb[NL802154_ATTR_MAX + 1];
++	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
++
++	nla_parse(tb, NL802154_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
++		  genlmsg_attrlen(gnlh, 0), NULL);
++
++	if (tb[NL802154_ATTR_SEC_DEVICE]) {
++		struct nlattr *tb_device[NL802154_DEV_ATTR_MAX + 1];
++		static struct nla_policy device_policy[NL802154_DEV_ATTR_MAX + 1] = {
++			[NL802154_DEV_ATTR_FRAME_COUNTER] = { NLA_U32 },
++			[NL802154_DEV_ATTR_PAN_ID] = { .type = NLA_U16 },
++			[NL802154_DEV_ATTR_SHORT_ADDR] = { .type = NLA_U16 },
++			[NL802154_DEV_ATTR_EXTENDED_ADDR] = { .type = NLA_U64 },
++			[NL802154_DEV_ATTR_SECLEVEL_EXEMPT] = { NLA_U8 },
++			[NL802154_DEV_ATTR_KEY_MODE] = { NLA_U32 },
++		};
++
++		if (nla_parse_nested(tb_device, NL802154_DEV_ATTR_MAX,
++				     tb[NL802154_ATTR_SEC_DEVICE],
++				     device_policy)) {
++			fprintf(stderr, "failed to parse nested attributes!\n");
++			return NL_SKIP;
++		}
++
++		printf("iwpan dev $WPAN_DEV device add ");
++
++		if (tb_device[NL802154_DEV_ATTR_FRAME_COUNTER])
++			printf("0x%08lx ", nla_get_u32(tb_device[NL802154_DEV_ATTR_FRAME_COUNTER]));
++		if (tb_device[NL802154_DEV_ATTR_PAN_ID])
++			printf("0x%04lx ", le16toh(nla_get_u16(tb_device[NL802154_DEV_ATTR_PAN_ID])));
++		if (tb_device[NL802154_DEV_ATTR_SHORT_ADDR])
++			printf("0x%04lx ", le16toh(nla_get_u16(tb_device[NL802154_DEV_ATTR_SHORT_ADDR])));
++		if (tb_device[NL802154_DEV_ATTR_EXTENDED_ADDR])
++			printf("0x%016" PRIx64 " ", le64toh(nla_get_u64(tb_device[NL802154_DEV_ATTR_EXTENDED_ADDR])));
++		if (tb_device[NL802154_DEV_ATTR_SECLEVEL_EXEMPT])
++			printf("%d ", nla_get_u8(tb_device[NL802154_DEV_ATTR_SECLEVEL_EXEMPT]));
++		if (tb_device[NL802154_DEV_ATTR_KEY_MODE])
++			printf("%d ", nla_get_u32(tb_device[NL802154_DEV_ATTR_KEY_MODE]));
++	}
++
++	printf("\n");
++
++	return NL_SKIP;
++}
++
++static int handle_device_dump(struct nl802154_state *state,
++				struct nl_cb *cb,
++				struct nl_msg *msg,
++				int argc, char **argv,
++				enum id_input id)
++{
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_device_handler, NULL);
++	return 0;
++}
++COMMAND(device, dump, NULL,
++	NL802154_CMD_GET_SEC_DEV, NLM_F_DUMP, CIB_NETDEV, handle_device_dump,
++	NULL);
++
++static int handle_device_add(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *device_msg;
++	unsigned long long extended_addr;
++	unsigned long frame_counter, pan_id, short_addr,
++		      seclevel_exempt, key_mode;
++	char *end;
++
++	if (argc < 1)
++		return 1;
++
++	/* frame_counter */
++	frame_counter = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* pan_id */
++	pan_id = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (pan_id > UINT16_MAX)
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* short_addr */
++	short_addr = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (short_addr > UINT16_MAX)
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* extended_addr */
++	extended_addr = strtoull(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* seclevel_exempt */
++	seclevel_exempt = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	if (seclevel_exempt > UINT8_MAX)
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* key_mode */
++	key_mode = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	device_msg = nlmsg_alloc();
++	if (!device_msg)
++		return -ENOMEM;
++
++	NLA_PUT_U32(device_msg, NL802154_DEV_ATTR_FRAME_COUNTER, frame_counter);
++	NLA_PUT_U16(device_msg, NL802154_DEV_ATTR_PAN_ID, htole16(pan_id));
++	NLA_PUT_U16(device_msg, NL802154_DEV_ATTR_SHORT_ADDR, htole16(short_addr));
++	NLA_PUT_U64(device_msg, NL802154_DEV_ATTR_EXTENDED_ADDR, htole64(extended_addr));
++	NLA_PUT_U8(device_msg, NL802154_DEV_ATTR_SECLEVEL_EXEMPT, seclevel_exempt);
++	NLA_PUT_U32(device_msg, NL802154_DEV_ATTR_KEY_MODE, key_mode);
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_DEVICE, device_msg);
++	nlmsg_free(device_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(device_msg);
++	return -ENOBUFS;
++}
++COMMAND(device, add, "<frame_counter> <pan_id> <short_addr> <extended_addr> <seclevel_exempt> <key_mode>",
++	NL802154_CMD_NEW_SEC_DEV, 0, CIB_NETDEV, handle_device_add, NULL);
++
++static int handle_device_del(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *device_msg;
++	unsigned long long extended_addr;
++	char *end;
++
++	if (argc < 1)
++		return 1;
++
++	/* extended_addr */
++	extended_addr = strtoull(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	device_msg = nlmsg_alloc();
++	if (!device_msg)
++		return -ENOMEM;
++
++	NLA_PUT_U64(device_msg, NL802154_DEV_ATTR_EXTENDED_ADDR, htole64(extended_addr));
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_DEVICE, device_msg);
++	nlmsg_free(device_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(device_msg);
++	return -ENOBUFS;
++}
++COMMAND(device, del, "<extended_addr>",
++	NL802154_CMD_DEL_SEC_DEV, 0, CIB_NETDEV, handle_device_del, NULL);
++
++SECTION(devkey);
++
++static int print_key_id(struct nlattr *tb) {
++	struct nlattr *tb_key_id[NL802154_KEY_ID_ATTR_MAX + 1];
++	static struct nla_policy key_id_policy[NL802154_KEY_ID_ATTR_MAX + 1] = {
++		[NL802154_KEY_ID_ATTR_MODE] = { .type = NLA_U32 },
++		[NL802154_KEY_ID_ATTR_INDEX] = { .type = NLA_U8 },
++		[NL802154_KEY_ID_ATTR_IMPLICIT] = { .type = NLA_NESTED },
++		[NL802154_KEY_ID_ATTR_SOURCE_SHORT] = { .type = NLA_U32 },
++		[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED] = { .type = NLA_U64 },
++	};
++
++	nla_parse_nested(tb_key_id, NL802154_KEY_ID_ATTR_MAX, tb, key_id_policy);
++
++	if (tb_key_id[NL802154_KEY_ID_ATTR_MODE]) {
++		enum nl802154_key_id_modes key_id_mode;
++
++		key_id_mode = nla_get_u32(tb_key_id[NL802154_KEY_ID_ATTR_MODE]);
++		printf("%d ", key_id_mode);
++		switch (key_id_mode) {
++		case NL802154_KEY_ID_MODE_IMPLICIT:
++			if (tb_key_id[NL802154_KEY_ID_ATTR_IMPLICIT]) {
++				struct nlattr *tb_dev_addr[NL802154_DEV_ADDR_ATTR_MAX + 1];
++				static struct nla_policy dev_addr_policy[NL802154_DEV_ADDR_ATTR_MAX + 1] = {
++					[NL802154_DEV_ADDR_ATTR_PAN_ID] = { .type = NLA_U16 },
++					[NL802154_DEV_ADDR_ATTR_MODE] = { .type = NLA_U32 },
++					[NL802154_DEV_ADDR_ATTR_SHORT] = { .type = NLA_U16 },
++					[NL802154_DEV_ADDR_ATTR_EXTENDED] = { .type = NLA_U64 },
++				};
++
++				nla_parse_nested(tb_dev_addr, NL802154_DEV_ADDR_ATTR_MAX,
++						 tb_key_id[NL802154_KEY_ID_ATTR_IMPLICIT],
++						 dev_addr_policy);
++
++				if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_PAN_ID])
++					printf("0x%04x ",
++					       le16toh(nla_get_u16(tb_dev_addr[NL802154_DEV_ADDR_ATTR_PAN_ID])));
++
++				if (tb_dev_addr[NL802154_DEV_ADDR_ATTR_MODE]) {
++					enum nl802154_dev_addr_modes dev_addr_mode;
++					dev_addr_mode = nla_get_u32(tb_dev_addr[NL802154_DEV_ADDR_ATTR_MODE]);
++					printf("%d ", dev_addr_mode);
++					switch (dev_addr_mode) {
++					case NL802154_DEV_ADDR_SHORT:
++						printf("0x%04x ",
++						       le16toh(nla_get_u16(tb_dev_addr[NL802154_DEV_ADDR_ATTR_SHORT])));
++						break;
++					case NL802154_DEV_ADDR_EXTENDED:
++						printf("0x%016" PRIx64 " ",
++						       le64toh(nla_get_u64(tb_dev_addr[NL802154_DEV_ADDR_ATTR_SHORT])));
++						break;
++					default:
++						/* TODO error handling */
++						break;
++					}
++				}
++			}
++			break;
++		case NL802154_KEY_ID_MODE_INDEX:
++			if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++				printf("0x%02x ",
++				       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++			break;
++		case NL802154_KEY_ID_MODE_INDEX_SHORT:
++			if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++				printf("0x%02x ",
++				       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++
++			if (tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_SHORT])
++				printf("0x%08lx ",
++				       le32toh(nla_get_u32(tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_SHORT])));
++			break;
++		case NL802154_KEY_ID_MODE_INDEX_EXTENDED:
++			if (tb_key_id[NL802154_KEY_ID_ATTR_INDEX])
++				printf("0x%02x ",
++				       nla_get_u8(tb_key_id[NL802154_KEY_ID_ATTR_INDEX]));
++
++			if (tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])
++				printf("0x%016" PRIx64 " ",
++				       le64toh(nla_get_u64(tb_key_id[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])));
++			break;
++		default:
++			/* TODO error handling */
++			return 0;
++		}
++	}
++
++	return 0;
++}
++
++static int print_devkey_handler(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *tb[NL802154_ATTR_MAX + 1];
++	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
++
++	nla_parse(tb, NL802154_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
++		  genlmsg_attrlen(gnlh, 0), NULL);
++
++	if (tb[NL802154_ATTR_SEC_DEVKEY]) {
++		struct nlattr *tb_devkey[NL802154_DEVKEY_ATTR_MAX + 1];
++		static struct nla_policy devkey_policy[NL802154_DEVKEY_ATTR_MAX + 1] = {
++			[NL802154_DEVKEY_ATTR_FRAME_COUNTER] = { NLA_U32 },
++			[NL802154_DEVKEY_ATTR_EXTENDED_ADDR] = { .type = NLA_U64 },
++			[NL802154_DEVKEY_ATTR_ID] = { .type = NLA_NESTED },
++		};
++
++		if (nla_parse_nested(tb_devkey, NL802154_DEVKEY_ATTR_MAX,
++				     tb[NL802154_ATTR_SEC_DEVKEY],
++				     devkey_policy)) {
++			fprintf(stderr, "failed to parse nested attributes!\n");
++			return NL_SKIP;
++		}
++
++		printf("iwpan dev $WPAN_DEV devkey add ");
++
++		if (tb_devkey[NL802154_DEV_ATTR_FRAME_COUNTER])
++			printf("0x%08lx ", nla_get_u32(tb_devkey[NL802154_DEVKEY_ATTR_FRAME_COUNTER]));
++		if (tb_devkey[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])
++			printf("0x%016" PRIx64 " ", le64toh(nla_get_u64(tb_devkey[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])));
++
++		if (tb_devkey[NL802154_DEVKEY_ATTR_ID])
++			print_key_id(tb_devkey[NL802154_DEVKEY_ATTR_ID]);
++	}
++
++	printf("\n");
++
++	return NL_SKIP;
++}
++
++static int handle_devkey_dump(struct nl802154_state *state,
++				struct nl_cb *cb,
++				struct nl_msg *msg,
++				int argc, char **argv,
++				enum id_input id)
++{
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_devkey_handler, NULL);
++	return 0;
++}
++COMMAND(devkey, dump, NULL,
++	NL802154_CMD_GET_SEC_DEVKEY, NLM_F_DUMP, CIB_NETDEV, handle_devkey_dump,
++	NULL);
++
++static int handle_devkey_add(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *devkey_msg = NULL;
++	unsigned long long extended_addr;
++	unsigned long frame_counter;
++	char *end;
++	int ret;
++
++	if (argc < 1)
++		return 1;
++
++	/* frame_counter */
++	frame_counter = strtoul(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	if (argc < 1)
++		return 1;
++
++	/* extended_addr */
++	extended_addr = strtoull(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	devkey_msg = nlmsg_alloc();
++	if (!devkey_msg)
++		return -ENOMEM;
++
++	NLA_PUT_U32(devkey_msg, NL802154_DEVKEY_ATTR_FRAME_COUNTER, frame_counter);
++	NLA_PUT_U64(devkey_msg, NL802154_DEVKEY_ATTR_EXTENDED_ADDR, htole64(extended_addr));
++
++	ret = handle_parse_key_id(devkey_msg, NL802154_DEVKEY_ATTR_ID, &argc, &argv);
++	if (ret) {
++		nlmsg_free(devkey_msg);
++		return ret;
++	}
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_DEVKEY, devkey_msg);
++	nlmsg_free(devkey_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(devkey_msg);
++	return -ENOBUFS;
++
++}
++COMMAND(devkey, add, "<frame_counter> <extended_addr> "
++	"<0 <pan_id> <2 <short_addr>|3 <extended_addr>>>|"
++	"<1 <index>>|"
++	"<2 <index> <source_short>>|"
++	"<3 <index> <source_extended>>",
++	NL802154_CMD_NEW_SEC_DEVKEY, 0, CIB_NETDEV, handle_devkey_add, NULL);
++
++static int handle_devkey_del(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *devkey_msg = NULL;
++	unsigned long long extended_addr;
++	char *end;
++	int ret;
++
++	if (argc < 1)
++		return 1;
++
++	/* extended_addr */
++	extended_addr = strtoull(argv[0], &end, 0);
++	if (*end != '\0')
++		return 1;
++
++	argc--;
++	argv++;
++
++	devkey_msg = nlmsg_alloc();
++	if (!devkey_msg)
++		return -ENOMEM;
++
++	NLA_PUT_U64(devkey_msg, NL802154_DEVKEY_ATTR_EXTENDED_ADDR, htole64(extended_addr));
++
++	ret = handle_parse_key_id(devkey_msg, NL802154_DEVKEY_ATTR_ID, &argc, &argv);
++	if (ret) {
++		nlmsg_free(devkey_msg);
++		return ret;
++	}
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_DEVKEY, devkey_msg);
++	nlmsg_free(devkey_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(devkey_msg);
++	return -ENOBUFS;
++
++}
++COMMAND(devkey, del, "<extended_addr> "
++	"<0 <pan_id> <2 <short_addr>|3 <extended_addr>>>|"
++	"<1 <index>>|"
++	"<2 <index> <source_short>>|"
++	"<3 <index> <source_extended>>",
++	NL802154_CMD_DEL_SEC_DEVKEY, 0, CIB_NETDEV, handle_devkey_del, NULL);
++
++SECTION(key);
++
++static void key_to_str(char *key, unsigned char *arg)
++{
++	int i, l;
++
++	l = 0;
++	for (i = 0; i < NL802154_KEY_SIZE ; i++) {
++		if (i == 0) {
++			sprintf(key+l, "%02x", arg[i]);
++			l += 2;
++		} else {
++			sprintf(key+l, ":%02x", arg[i]);
++			l += 3;
++		}
++	}
++}
++
++static int print_key_handler(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *tb[NL802154_ATTR_MAX + 1];
++	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
++
++	nla_parse(tb, NL802154_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
++		  genlmsg_attrlen(gnlh, 0), NULL);
++
++	if (tb[NL802154_ATTR_SEC_KEY]) {
++		struct nlattr *tb_key[NL802154_KEY_ATTR_MAX + 1];
++		static struct nla_policy key_policy[NL802154_KEY_ATTR_MAX + 1] = {
++			[NL802154_KEY_ATTR_ID] = { NLA_NESTED },
++			[NL802154_KEY_ATTR_USAGE_FRAMES] = { NLA_U8 },
++			[NL802154_KEY_ATTR_USAGE_CMDS] = { .minlen = NL802154_CMD_FRAME_NR_IDS / 8 },
++			[NL802154_KEY_ATTR_BYTES] = { .minlen = NL802154_KEY_SIZE },
++		};
++
++		if (nla_parse_nested(tb_key, NL802154_KEY_ATTR_MAX,
++				     tb[NL802154_ATTR_SEC_KEY],
++				     key_policy)) {
++			fprintf(stderr, "failed to parse nested attributes!\n");
++			return NL_SKIP;
++		}
++
++		printf("iwpan dev $WPAN_DEV key add ");
++
++		if (tb_key[NL802154_KEY_ATTR_USAGE_FRAMES])
++			printf("0x%02x ", nla_get_u8(tb_key[NL802154_KEY_ATTR_USAGE_FRAMES]));
++
++		if (tb_key[NL802154_KEY_ATTR_USAGE_CMDS]) {
++			uint32_t cmds[NL802154_CMD_FRAME_NR_IDS / 32];
++
++			nla_memcpy(cmds, tb_key[NL802154_KEY_ATTR_USAGE_CMDS],
++				   NL802154_CMD_FRAME_NR_IDS / 8);
++			printf("0x%08x ", cmds[7]);
++		}
++
++		if (tb_key[NL802154_KEY_ATTR_BYTES]) {
++			uint8_t key[NL802154_KEY_SIZE];
++			char key_str[512] = "";
++
++			nla_memcpy(key, tb_key[NL802154_KEY_ATTR_BYTES],
++				   NL802154_KEY_SIZE);
++
++			key_to_str(key_str, key);
++			printf("%s ", key_str);
++		}
++
++		if (tb_key[NL802154_KEY_ATTR_ID])
++			print_key_id(tb_key[NL802154_KEY_ATTR_ID]);
++	}
++
++	printf("\n");
++
++	return NL_SKIP;
++}
++
++static int handle_key_dump(struct nl802154_state *state,
++			   struct nl_cb *cb,
++			   struct nl_msg *msg,
++			   int argc, char **argv,
++			   enum id_input id)
++{
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_key_handler, NULL);
++	return 0;
++}
++COMMAND(key, dump, NULL,
++	NL802154_CMD_GET_SEC_KEY, NLM_F_DUMP, CIB_NETDEV, handle_key_dump,
++	NULL);
++
++#define BIT(x)  (1 << (x))
++
++static int str_to_key(unsigned char *key, char *arg)
++{
++	int i;
++
++	for (i = 0; i < NL802154_KEY_SIZE; i++) {
++		int temp;
++		char *cp = strchr(arg, ':');
++		if (cp) {
++			*cp = 0;
++			cp++;
++		}
++		if (sscanf(arg, "%x", &temp) != 1)
++			return -1;
++		if (temp < 0 || temp > 255)
++			return -1;
++
++		key[i] = temp;
++		if (!cp)
++			break;
++		arg = cp;
++	}
++	if (i < NL802154_KEY_SIZE - 1)
++		return -1;
++
++	return 0;
++}
++
++static int handle_key_add(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *key_msg = NULL;
++	uint8_t key_bytes[NL802154_KEY_SIZE] = { };
++	uint32_t commands[NL802154_CMD_FRAME_NR_IDS / 32] = { };
++	unsigned long tmp;
++	char *end;
++	int ret, i;
++
++	key_msg = nlmsg_alloc();
++	if (!key_msg)
++		return -ENOMEM;
++
++	if (argc < 1) {
++		nlmsg_free(key_msg);
++		return 1;
++	}
++
++	/* frame_types */
++	tmp = strtoul(argv[0], &end, 0);
++	if (*end != '\0') {
++		nlmsg_free(key_msg);
++		return 1;
++	}
++
++	if (tmp > UINT8_MAX) {
++		nlmsg_free(key_msg);
++		return 1;
++	}
++
++	NLA_PUT_U8(key_msg, NL802154_KEY_ATTR_USAGE_FRAMES, tmp);
++
++	argc--;
++	argv++;
++
++	if (tmp & BIT(NL802154_FRAME_CMD)) {
++		if (argc < 1) {
++			nlmsg_free(key_msg);
++			return 1;
++		}
++
++		/* commands[7] */
++		commands[7] = strtoul(argv[0], &end, 0);
++		if (*end != '\0') {
++			nlmsg_free(key_msg);
++			return 1;
++		}
++
++		NLA_PUT(key_msg, NL802154_KEY_ATTR_USAGE_CMDS,
++			NL802154_CMD_FRAME_NR_IDS / 8, commands);
++
++		argc--;
++		argv++;
++	}
++
++	if (argc < 1) {
++		nlmsg_free(key_msg);
++		return 1;
++	}
++
++	str_to_key(key_bytes, argv[0]);
++
++	NLA_PUT(key_msg, NL802154_KEY_ATTR_BYTES, NL802154_KEY_SIZE, key_bytes);
++
++	argc--;
++	argv++;
++
++	ret = handle_parse_key_id(key_msg, NL802154_KEY_ATTR_ID, &argc, &argv);
++	if (ret) {
++		nlmsg_free(key_msg);
++		return ret;
++	}
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_KEY, key_msg);
++	nlmsg_free(key_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(key_msg);
++	return -ENOBUFS;
++
++}
++COMMAND(key, add, "<frame_types <if 0x4 is set commands[7]>> <key <hex as 00:11:..>> "
++	"<0 <pan_id> <2 <short_addr>|3 <extended_addr>>>|"
++	"<1 <index>>|"
++	"<2 <index> <source_short>>|"
++	"<3 <index> <source_extended>>",
++	NL802154_CMD_NEW_SEC_KEY, 0, CIB_NETDEV, handle_key_add, NULL);
++
++static int handle_key_del(struct nl802154_state *state, struct nl_cb *cb,
++			     struct nl_msg *msg, int argc, char **argv,
++			     enum id_input id)
++{
++	struct nl_msg *key_msg = NULL;
++	int ret;
++
++	key_msg = nlmsg_alloc();
++	if (!key_msg)
++		return -ENOMEM;
++
++	ret = handle_parse_key_id(key_msg, NL802154_KEY_ATTR_ID, &argc, &argv);
++	if (ret) {
++		nlmsg_free(key_msg);
++		return ret;
++	}
++
++	nla_put_nested(msg, NL802154_ATTR_SEC_KEY, key_msg);
++	nlmsg_free(key_msg);
++
++	return 0;
++
++nla_put_failure:
++	nlmsg_free(key_msg);
++	return -ENOBUFS;
++
++}
++COMMAND(key, del,
++	"<0 <pan_id> <2 <short_addr>|3 <extended_addr>>>|"
++	"<1 <index>>|"
++	"<2 <index> <source_short>>|"
++	"<3 <index> <source_extended>>",
++	NL802154_CMD_DEL_SEC_KEY, 0, CIB_NETDEV, handle_key_del, NULL);
+-- 
+2.5.3
diff --git a/package/wpan-tools/0001-src-nl_extras.h-fix-compatibility-with-libnl-3.3.0.patch b/package/wpan-tools/0001-src-nl_extras.h-fix-compatibility-with-libnl-3.3.0.patch
deleted file mode 100644
index 8b881ad..0000000
--- a/package/wpan-tools/0001-src-nl_extras.h-fix-compatibility-with-libnl-3.3.0.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From bb522bd584f05e6658d5dba97f48ca018f46394c Mon Sep 17 00:00:00 2001
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Sat, 6 May 2017 14:36:08 +0200
-Subject: [PATCH] src/nl_extras.h: fix compatibility with libnl 3.3.0
-
-nl_extras.h defines a set of nla_set_s*() functions if not provided by
-libnl. They are provided by libnl since version 3.2.26. The test
-(LIBNL_VER_MIC <= 26) was working fine while libnl was in the 3.2.x
-series, but now that they have incremented the minor version, the
-micro version was reset to 0, with the latest libnl version being
-3.3.0.
-
-Due to this, the condition (LIBNL_VER_MIC <= 26) is true, and we get
-redefinition errors because nl_extras.h redefines functions already
-provided by libnl.
-
-This commit improves the condition so that nl_extras.h provides the
-missing functions only if the minor version is < 2, or if minor is 2
-and micro is < 26.
-
-Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
----
- src/nl_extras.h | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/src/nl_extras.h b/src/nl_extras.h
-index c4d1d14..37844f9 100644
---- a/src/nl_extras.h
-+++ b/src/nl_extras.h
-@@ -1,7 +1,7 @@
- #ifndef __NL_EXTRAS_H
- #define __NL_EXTRAS_H
- 
--#if LIBNL_VER_MIC <= 26
-+#if (LIBNL_VER_MIN < 2) || (LIBNL_VER_MIN == 2) && (LIBNL_VER_MIC <= 26)
- 
- #ifndef NLA_S8
- 
-@@ -45,6 +45,6 @@ static inline int32_t nla_get_s32(struct nlattr *nla)
- 
- #endif /* NLA_S64 */
- 
--#endif /* LIBNL_VER_MIC */
-+#endif /* LIBNL_VER_* */
- 
- #endif /* __NL_EXTRAS_H */
--- 
-2.7.4
-
diff --git a/package/wpan-tools/0002-security-add-store-and-restore-scripts.patch b/package/wpan-tools/0002-security-add-store-and-restore-scripts.patch
new file mode 100644
index 0000000..db1f9b3
--- /dev/null
+++ b/package/wpan-tools/0002-security-add-store-and-restore-scripts.patch
@@ -0,0 +1,118 @@
+This patch adds two new bash script commands."iwpan-store" and
+"iwpan-restore" which can store and restore the current security
+table settings. This is currently a very KISS solution, we should lookup
+iptables implementation for storing and restoring the tables.
+
+Signed-off-by: Alexander Aring <alex.aring@xxxxxxxxx>
+---
+ src/Makefile.am   |  4 ++++
+ src/iwpan-restore | 36 ++++++++++++++++++++++++++++++++++++
+ src/iwpan-store   | 39 +++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 79 insertions(+)
+ create mode 100755 src/iwpan-restore
+ create mode 100755 src/iwpan-store
+
+diff --git a/src/Makefile.am b/src/Makefile.am
+index b2177a2..37a6d82 100644
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -1,6 +1,10 @@
+ bin_PROGRAMS = \
+ 	iwpan
+ 
++bin_SCRIPTS = \
++	iwpan-store \
++	iwpan-restore
++
+ iwpan_SOURCES = \
+ 	iwpan.c \
+ 	iwpan.h \
+diff --git a/src/iwpan-restore b/src/iwpan-restore
+new file mode 100755
+index 0000000..0e305f6
+--- /dev/null
++++ b/src/iwpan-restore
+@@ -0,0 +1,36 @@
++#!/bin/sh
++
++WPAN_DEV=""
++FILE=""
++
++function usage() {
++	echo "usage: -d \$WPAN_DEV -f \$FILE"
++}
++
++while getopts "d:f:" opt; do
++	case $opt in
++		d)
++			WPAN_DEV=$OPTARG
++			;;
++		f)
++			FILE=$OPTARG
++			;;
++		?)
++			usage
++			;;
++	esac
++done
++
++if [ -z $FILE ] || [ -z $WPAN_DEV ]
++then
++	usage
++	exit 1
++fi
++
++function failed() {
++	echo "failed" >&2
++}
++
++export WPAN_DEV &&
++/bin/bash $FILE ||
++failed
+diff --git a/src/iwpan-store b/src/iwpan-store
+new file mode 100755
+index 0000000..acce807
+--- /dev/null
++++ b/src/iwpan-store
+@@ -0,0 +1,39 @@
++#!/bin/sh
++
++WPAN_DEV=""
++FILE=""
++
++function usage() {
++	echo "usage: -d \$WPAN_DEV -f \$FILE"
++}
++
++while getopts "d:f:" opt; do
++	case $opt in
++		d)
++			WPAN_DEV=$OPTARG
++			;;
++		f)
++			FILE=$OPTARG
++			;;
++		?)
++			usage
++			;;
++	esac
++done
++
++if [ -z $FILE ] || [ -z $WPAN_DEV ]
++then
++	usage
++	exit 1
++fi
++
++function failed() {
++	echo "failed" >&2
++	rm $FILE
++}
++
++iwpan dev $WPAN_DEV seclevel dump > $FILE &&
++iwpan dev $WPAN_DEV device dump >> $FILE &&
++iwpan dev $WPAN_DEV devkey dump >> $FILE &&
++iwpan dev $WPAN_DEV key dump >> $FILE ||
++failed
+-- 
+2.5.3
diff --git a/package/wpan-tools/0003-examples-improvements.patch b/package/wpan-tools/0003-examples-improvements.patch
new file mode 100644
index 0000000..6600438
--- /dev/null
+++ b/package/wpan-tools/0003-examples-improvements.patch
@@ -0,0 +1,413 @@
+diff --git a/examples/af_ieee802154_rx.c b/examples/af_ieee802154_rx.c
+index 86ba707..10edac7 100644
+--- a/examples/af_ieee802154_rx.c
++++ b/examples/af_ieee802154_rx.c
+@@ -29,7 +29,7 @@
+ 
+ #define IEEE802154_ADDR_LEN 8
+ #define MAX_PACKET_LEN 127
+-#define EXTENDED 1
++//#define EXTENDED
+ 
+ enum {
+ 	IEEE802154_ADDR_NONE = 0x0,
+@@ -56,12 +56,14 @@ int main(int argc, char *argv[]) {
+ 	struct sockaddr_ieee802154 src, dst;
+ 	unsigned char buf[MAX_PACKET_LEN + 1];
+ 	socklen_t addrlen;
++#if defined(EXTENDED) /* IEEE 802.15.4 extended address usage */
+ 	/* IEEE 802.15.4 extended address to receive frames on, adapt to your setup */
+-	uint8_t long_addr[IEEE802154_ADDR_LEN] = {0xd6, 0x55, 0x2c, 0xd6, 0xe4, 0x1c, 0xeb, 0x57};
++	uint8_t long_addr[IEEE802154_ADDR_LEN] = {0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0x00, 0x01};
++#endif
+ 
+ 	/* Create IEEE 802.15.4 address family socket for the SOCK_DGRAM type */
+ 	sd = socket(PF_IEEE802154, SOCK_DGRAM, 0);
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+ 		return 1;
+ 	}
+@@ -69,39 +71,40 @@ int main(int argc, char *argv[]) {
+ 	/* Prepare source socket address struct */
+ 	memset(&src, 0, sizeof(src));
+ 	src.family = AF_IEEE802154;
+-	/* Used PAN ID is 0x23 here, adapt to your setup */
+-	src.addr.pan_id = 0x0023;
++	/* Used PAN ID is 0xbeef here, adapt to your setup */
++	src.addr.pan_id = 0xbeef;
+ 
+-#if EXTENDED /* IEEE 802.15.4 extended address usage */
++#if defined(EXTENDED) /* IEEE 802.15.4 extended address usage */
+ 	src.addr.addr_type = IEEE802154_ADDR_LONG;
+ 	memcpy(&src.addr.hwaddr, &long_addr, IEEE802154_ADDR_LEN);
+ #else
+ 	src.addr.addr_type = IEEE802154_ADDR_SHORT;
+-	src.addr.short_addr = 0x0002;
++	src.addr.short_addr = 0x0001;
+ #endif
+ 
+ 	/* Bind socket on this side */
+ 	ret = bind(sd, (struct sockaddr *)&src, sizeof(src));
+-	if (ret) {
++	if(ret) {
+ 		perror("bind");
+ 		close(sd);
+ 		return 1;
+ 	}
+ 
+ 	addrlen = sizeof(dst);
++	printf("Waiting for data receive...\n");
+ 
+ 	/* Infinite loop receiving 802.15.4 frames and print out */
+-	while (1) {
++	for(;;) {
+ 		ret = recvfrom(sd, buf, MAX_PACKET_LEN, 0, (struct sockaddr *)&dst, &addrlen);
+-		if (ret < 0) {
++		if(ret < 0) {
+ 			perror("recvfrom");
+ 			continue;
+ 		}
+ 		buf[ret] = '\0';
+ #if EXTENDED
+-		printf("Received (from %s): %s\n", dst.addr.hwaddr, buf);
++		printf("Received(%d) (from %s): %s\n", ret, dst.addr.hwaddr, buf);
+ #else
+-		printf("Received (from %x): %s\n", dst.addr.short_addr, buf);
++		printf("Received(%d) (from %#06x): %s\n", ret, dst.addr.short_addr, buf);
+ #endif
+ 	}
+ 
+diff --git a/examples/af_ieee802154_tx.c b/examples/af_ieee802154_tx.c
+index e85a109..3108fa5 100644
+--- a/examples/af_ieee802154_tx.c
++++ b/examples/af_ieee802154_tx.c
+@@ -29,7 +29,7 @@
+ 
+ #define IEEE802154_ADDR_LEN 8
+ #define MAX_PACKET_LEN 127
+-#define EXTENDED 1
++//#define EXTENDED
+ 
+ enum {
+ 	IEEE802154_ADDR_NONE = 0x0,
+@@ -56,12 +56,14 @@ int main(int argc, char *argv[]) {
+ 	ssize_t len;
+ 	struct sockaddr_ieee802154 dst;
+ 	unsigned char buf[MAX_PACKET_LEN + 1];
++#if defined(EXTENDED) /* IEEE 802.15.4 extended address usage */
+ 	/* IEEE 802.15.4 extended send address, adapt to your setup */
+-	uint8_t long_addr[IEEE802154_ADDR_LEN] = {0xd6, 0x55, 0x2c, 0xd6, 0xe4, 0x1c, 0xeb, 0x57};
++	uint8_t long_addr[IEEE802154_ADDR_LEN] = {0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0x00, 0x01};
++#endif
+ 
+ 	/* Create IEEE 802.15.4 address family socket for the SOCK_DGRAM type */
+ 	sd = socket(PF_IEEE802154, SOCK_DGRAM, 0);
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+ 		return 1;
+ 	}
+@@ -69,15 +71,15 @@ int main(int argc, char *argv[]) {
+ 	/* Prepare destination socket address struct */
+ 	memset(&dst, 0, sizeof(dst));
+ 	dst.family = AF_IEEE802154;
+-	/* Used PAN ID is 0x23 here, adapt to your setup */
+-	dst.addr.pan_id = 0x0023;
++	/* Used PAN ID is 0xbeef here, adapt to your setup */
++	dst.addr.pan_id = 0xbeef;
+ 
+-#if EXTENDED /* IEEE 802.15.4 extended address usage */
++#if defined(EXTENDED) /* IEEE 802.15.4 extended address usage */
+ 	dst.addr.addr_type = IEEE802154_ADDR_LONG;
+ 	memcpy(&dst.addr.hwaddr, long_addr, IEEE802154_ADDR_LEN);
+ #else
+ 	dst.addr.addr_type = IEEE802154_ADDR_SHORT;
+-	dst.addr.short_addr = 0x0002;
++	dst.addr.short_addr = 0x0001;
+ #endif
+ 
+ 	sprintf(buf, "Hello world from IEEE 802.15.4 socket example!");
+@@ -85,8 +87,10 @@ int main(int argc, char *argv[]) {
+ 	/* sendto() is used for implicity in this example, bin()/send() would
+ 	 * be an alternative */
+ 	len = sendto(sd, buf, strlen(buf), 0, (struct sockaddr *)&dst, sizeof(dst));
+-	if (len < 0) {
++	if(len < 0) {
+ 		perror("sendto");
++	} else {
++		printf("Data sent ok.\n");
+ 	}
+ 
+ 	shutdown(sd, SHUT_RDWR);
+diff --git a/examples/af_inet6_rx.c b/examples/af_inet6_rx.c
+index d512471..2a2a902 100644
+--- a/examples/af_inet6_rx.c
++++ b/examples/af_inet6_rx.c
+@@ -39,7 +39,7 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Create IPv6 address family socket for the SOCK_DGRAM type */
+ 	sd = socket(PF_INET6, SOCK_DGRAM, 0);
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+ 		return 1;
+ 	}
+@@ -54,24 +54,25 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Bind socket on this side */
+ 	ret = bind(sd, (struct sockaddr *)&src, sizeof(src));
+-	if (ret) {
++	if(ret) {
+ 		perror("bind");
+ 		close(sd);
+ 		return 1;
+ 	}
+ 
+ 	addrlen = sizeof(dst);
++	printf("Waiting for data receive...\n");
+ 
+ 	/* Infinite loop receiving IPv6 packets and print out */
+-	while (1) {
++	for(;;) {
+ 		len = recvfrom(sd, buf, MAX_PACKET_LEN, 0, (struct sockaddr *)&dst, &addrlen);
+-		if (len < 0) {
++		if(len < 0) {
+ 			perror("recvfrom");
+ 			continue;
+ 		}
+ 		buf[len] = '\0';
+ 		inet_ntop(AF_INET6, &(dst.sin6_addr), ipv6, INET6_ADDRSTRLEN);
+-		printf("Received (from %s): %s\n", ipv6, buf);
++		printf("Received(%d) (from %s): %s\n", (int)len, ipv6, buf);
+ 	}
+ 
+ 	shutdown(sd, SHUT_RDWR);
+diff --git a/examples/af_inet6_tx.c b/examples/af_inet6_tx.c
+index 9fe7491..35dca79 100644
+--- a/examples/af_inet6_tx.c
++++ b/examples/af_inet6_tx.c
+@@ -28,7 +28,6 @@
+ #include <arpa/inet.h>
+ #include <net/if.h>
+ 
+-#define IEEE802154_ADDR_LEN 8
+ #define MAX_PACKET_LEN 2048
+ 
+ int main(int argc, char *argv[]) {
+@@ -37,20 +36,26 @@ int main(int argc, char *argv[]) {
+ 	struct ifreq ifr;
+ 	unsigned char buf[MAX_PACKET_LEN + 1];
+ 
++	if(argc != 2) {
++		printf("Usage: %s [inet_addr]\n", argv[0]);
++		return 1;
++	}
++
+ 	/* Create IPv6 address family socket for the SOCK_DGRAM type */
+ 	sd = socket(PF_INET6, SOCK_DGRAM, 0);
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+-		return 1;
++		return 2;
+ 	}
+ 
+ 	/* Bind the socket to lowpan0 to make sure we send over it, adapt to your setup */
+ 	memset(&ifr, 0, sizeof(ifr));
+ 	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "lowpan0");
+ 	ret = setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, (void *)&ifr, sizeof(ifr));
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("setsockopt");
+-		return 1;
++		close(sd);
++		return 3;
+ 	}
+ 
+ 	/* Prepare destination socket address struct */
+@@ -58,15 +63,17 @@ int main(int argc, char *argv[]) {
+ 	dst.sin6_family = AF_INET6;
+ 	/* Port within the compressed port range for potential NHC UDP compression */
+ 	dst.sin6_port = htons(61617);
+-	inet_pton(AF_INET6, "ff02::1", &(dst.sin6_addr));
++	inet_pton(AF_INET6, argv[1], &(dst.sin6_addr));
+ 
+ 	sprintf(buf, "Hello world from AF_INET6 socket example!");
+ 
+ 	/* sendto() is used for implicity in this example, bin()/send() would
+ 	 * be an alternative */
+ 	ret = sendto(sd, buf, strlen(buf), 0, (struct sockaddr *)&dst, sizeof(dst));
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("sendto");
++	} else {
++		printf("Data sent ok.\n");
+ 	}
+ 
+ 	shutdown(sd, SHUT_RDWR);
+diff --git a/examples/af_packet_rx.c b/examples/af_packet_rx.c
+index 9770965..76017ae 100644
+--- a/examples/af_packet_rx.c
++++ b/examples/af_packet_rx.c
+@@ -39,6 +39,34 @@
+ #define ETH_P_IEEE802154 0x00F6
+ #endif
+ 
++void dumpbuf(void *pdata, int len) {
++	const unsigned char *buf = (const unsigned char*)pdata;
++	char outbuf[1024], outbuf2[1024];
++	int olen = 0, olen2 = 0;
++	int i;
++	for(i = 0; i < len; ) {
++		if(i % 8 == 0) {
++			olen = olen2 = 0;
++			outbuf[olen] = outbuf2[olen2] = '\0';
++			olen += snprintf(outbuf + olen, sizeof(outbuf) - olen, "%03x: ", i);
++			if(i > len - 8) {
++				int j;
++				for(j = len % 8; j < 8; j++)
++					olen2 += snprintf(outbuf2 + olen2, sizeof(outbuf2) - olen2, "   ");
++			}
++			//olen2 += snprintf(outbuf2 + olen2, sizeof(outbuf2) - olen2, " ");
++		}
++
++		outbuf2[olen2++] = (buf[i] > ' ' && buf[i] < 0x7f) ? buf[i] : '.';
++		olen += snprintf(outbuf + olen, sizeof(outbuf) - olen, "%02x ", buf[i++]);
++
++		if((i % 8 == 0) || (i == len)) {
++			outbuf2[olen2] = '\0';
++			printf("%s%s\n", outbuf, outbuf2);
++		}
++	}
++}
++
+ int main(int argc, char *argv[]) {
+ 	int ret, sd, i;
+ 	ssize_t len;
+@@ -48,15 +76,15 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Create AF_PACKET address family socket for the SOCK_RAW type */
+ 	sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IEEE802154));
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+ 		return 1;
+ 	}
+ 
+ 	/* Get interface index */
+-	strncpy(ifr.ifr_name, "monitor0", IFNAMSIZ);
++	strncpy(ifr.ifr_name, "wpan0", IFNAMSIZ);
+ 	ret = ioctl(sd, SIOCGIFINDEX, &ifr);
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("ioctl");
+ 		close(sd);
+ 		return 1;
+@@ -70,23 +98,23 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Bind socket on this side */
+ 	ret = bind(sd, (struct sockaddr *)&sll, sizeof(sll));
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("bind");
+ 		close(sd);
+ 		return 1;
+ 	}
+ 
+-	while (1) {
++	printf("Waiting for data receive...\n");
++
++	for(;;) {
+ 		/* Receive and print the whole packet payload, including FCS */
+ 		len = recv(sd, buf, MAX_PACKET_LEN, 0);
+-		if (len < 0) {
++		if(len < 0) {
+ 			perror("recv");
+ 			continue;
+ 		}
+-		printf("Received:");
+-		for (i = 0; i < len; i++)
+-			printf(" %x", buf[i]);
+-		printf("\n");
++		printf("Received(%d):\n", (int)len);
++		dumpbuf(buf, len);
+ 	}
+ 
+ 	shutdown(sd, SHUT_RDWR);
+diff --git a/examples/af_packet_tx.c b/examples/af_packet_tx.c
+index 82a15f4..01e6d4f 100644
+--- a/examples/af_packet_tx.c
++++ b/examples/af_packet_tx.c
+@@ -46,7 +46,7 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Create AF_PACKET address family socket for the SOCK_RAW type */
+ 	sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IEEE802154));
+-	if (sd < 0) {
++	if(sd < 0) {
+ 		perror("socket");
+ 		return 1;
+ 	}
+@@ -55,7 +55,7 @@ int main(int argc, char *argv[]) {
+ 	 * bytes from payload, using the normal IEEE 802.15.4 interface here */
+ 	strncpy(ifr.ifr_name, "wpan0", IFNAMSIZ);
+ 	ret = ioctl(sd, SIOCGIFINDEX, &ifr);
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("ioctl");
+ 		close(sd);
+ 		return 1;
+@@ -69,7 +69,7 @@ int main(int argc, char *argv[]) {
+ 
+ 	/* Bind socket on this side */
+ 	ret = bind(sd, (struct sockaddr *)&sll, sizeof(sll));
+-	if (ret < 0) {
++	if(ret < 0) {
+ 		perror("bind");
+ 		close(sd);
+ 		return 1;
+@@ -79,28 +79,30 @@ int main(int argc, char *argv[]) {
+ 	buf[0] = 0x21; /* Frame Control Field */
+ 	buf[1] = 0xc8; /* Frame Control Field */
+ 	buf[2] = 0x8b; /* Sequence number */
+-	buf[3] = 0xff; /* Destination PAN ID 0xffff */
+-	buf[4] = 0xff; /* Destination PAN ID */
+-	buf[5] = 0x02; /* Destination short address 0x0002 */
++	buf[3] = 0xef; /* Destination PAN ID 0xbeef */
++	buf[4] = 0xbe; /* Destination PAN ID */
++	buf[5] = 0x01; /* Destination short address 0x0001 */
+ 	buf[6] = 0x00; /* Destination short address */
+-	buf[7] = 0x23; /* Source PAN ID 0x0023 */
+-	buf[8] = 0x00; /* */
+-	buf[9] = 0x60; /* Source extended address ae:c2:4a:1c:21:16:e2:60 */
+-	buf[10] = 0xe2; /* */
+-	buf[11] = 0x16; /* */
+-	buf[12] = 0x21; /* */
+-	buf[13] = 0x1c; /* */
+-	buf[14] = 0x4a; /* */
+-	buf[15] = 0xc2; /* */
+-	buf[16] = 0xae; /* */
++	buf[7] = 0xef; /* Source PAN ID 0xbeef */
++	buf[8] = 0xbe; /* */
++	buf[9] = 0x01; /* Source extended address de:ad:be:ef:ba:be:00:01  */
++	buf[10] = 0x00; /* */
++	buf[11] = 0xbe; /* */
++	buf[12] = 0xba; /* */
++	buf[13] = 0xef; /* */
++	buf[14] = 0xbe; /* */
++	buf[15] = 0xad; /* */
++	buf[16] = 0xde; /* */
+ 	buf[17] = 0xAA; /* Payload */
+ 	buf[18] = 0xBB; /* */
+ 	buf[19] = 0xCC; /* */
+ 
+ 	/* Send constructed packet over binded interface */
+ 	len = send(sd, buf, 20, 0);
+-	if (len < 0) {
++	if(len < 0) {
+ 		perror("send");
++	} else {
++		printf("Data sent ok.\n");
+ 	}
+ 
+ 	shutdown(sd, SHUT_RDWR);
diff --git a/package/wpan-tools/wpan-tools.hash b/package/wpan-tools/wpan-tools.hash
deleted file mode 100644
index 6a3b6d1..0000000
--- a/package/wpan-tools/wpan-tools.hash
+++ /dev/null
@@ -1,4 +0,0 @@
-# From http://wpan.cakelab.org/releases/md5sum
-md5	06608f69951088844196f79685318aa9	wpan-tools-0.7.tar.gz
-# Calculated based on the hash above
-sha256	8b690ff0e71e08bece5ec541223fda7abd2d5552d97d3d25b4967609b58fef00	wpan-tools-0.7.tar.gz
diff --git a/package/wpan-tools/wpan-tools.mk b/package/wpan-tools/wpan-tools.mk
index a604dab..993bfd9 100644
--- a/package/wpan-tools/wpan-tools.mk
+++ b/package/wpan-tools/wpan-tools.mk
@@ -4,10 +4,13 @@
 #
 ################################################################################
 
-WPAN_TOOLS_VERSION = 0.7
-WPAN_TOOLS_SITE = http://wpan.cakelab.org/releases
+WPAN_TOOLS_VERSION = 77ae6f363e0bbd667f688fbfcb1a33024c026c2d
+WPAN_TOOLS_SITE = https://github.com/linux-wpan/wpan-tools.git
+WPAN_TOOLS_SITE_METHOD = git
 WPAN_TOOLS_DEPENDENCIES = host-pkgconf libnl
-WPAN_TOOLS_LICENSE = ISC
-WPAN_TOOLS_LICENSE_FILES = COPYING
+WPAN_TOOLS_AUTORECONF = YES
+WPAN_TOOLS_AUTORECONF_OPTS = --install --symlink
+WPAN_TOOLS_CONF_OPTS = CFLAGS='-O2' --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
+WPAN_TOOLS_LIBTOOL_PATCH = NO
 
 $(eval $(autotools-package))
-- 
2.7.4

